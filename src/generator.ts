import type { AnalysisResult, GeneratorOptions } from './types.js';

export function generateClaudeMd(result: AnalysisResult, options: GeneratorOptions): string {
  if (options.template === 'minimal') {
    return generateMinimal(result);
  }
  return generateFull(result, options);
}

// ============================================
// Minimal Template
// ============================================

function generateMinimal(result: AnalysisResult): string {
  const { projectName, stack, commands, patterns } = result;
  
  const lines: string[] = [];

  // Header
  lines.push(`# ${projectName}`);
  lines.push('');

  // Tech Stack
  lines.push('## Tech Stack');
  lines.push(`- **Language**: ${formatLanguage(stack.language)}${stack.languageVersion ? ` ${stack.languageVersion}` : ''}`);
  if (stack.framework !== 'unknown') {
    lines.push(`- **Framework**: ${formatFramework(stack.framework)}${stack.frameworkVersion ? ` ${stack.frameworkVersion}` : ''}`);
  }
  if (stack.testFramework !== 'unknown') {
    lines.push(`- **Testing**: ${formatTestFramework(stack.testFramework)}`);
  }
  if (stack.styling) {
    lines.push(`- **Styling**: ${stack.styling}`);
  }
  lines.push('');

  // Commands
  if (Object.keys(commands).length > 0) {
    lines.push('## Commands');
    lines.push('```bash');
    if (commands.dev) lines.push(`# Development\n${commands.dev}`);
    if (commands.build) lines.push(`\n# Build\n${commands.build}`);
    if (commands.test) lines.push(`\n# Test\n${commands.test}`);
    if (commands.lint) lines.push(`\n# Lint\n${commands.lint}`);
    lines.push('```');
    lines.push('');
  }

  // Key Conventions
  lines.push('## Conventions');
  
  if (patterns.naming.files.components) {
    lines.push(`- Component files: ${patterns.naming.files.components}`);
  }
  if (patterns.naming.files.tests) {
    lines.push(`- Test files: ${patterns.naming.files.tests}`);
  }
  if (patterns.structure.type !== 'unknown') {
    lines.push(`- Project structure: ${formatStructureType(patterns.structure.type)}`);
  }
  if (patterns.imports?.style) {
    lines.push(`- Imports: ${patterns.imports.style}`);
  }
  lines.push('');

  // Footer
  lines.push('---');
  lines.push(`*Generated by Proteus on ${new Date().toISOString().split('T')[0]}*`);

  return lines.join('\n');
}

// ============================================
// Full Template
// ============================================

function generateFull(result: AnalysisResult, options: GeneratorOptions): string {
  const { projectName, description, stack, commands, patterns, confidence } = result;
  
  const lines: string[] = [];

  // Header
  lines.push(`# ${projectName}`);
  lines.push('');
  
  if (description) {
    lines.push(`> ${description}`);
    lines.push('');
  }

  // Tech Stack Table
  lines.push('## Tech Stack');
  lines.push('');
  lines.push('| Category | Technology | Version |');
  lines.push('|----------|------------|---------|');
  lines.push(`| Language | ${formatLanguage(stack.language)} | ${stack.languageVersion || '-'} |`);
  if (stack.framework !== 'unknown') {
    lines.push(`| Framework | ${formatFramework(stack.framework)} | ${stack.frameworkVersion || '-'} |`);
  }
  if (stack.testFramework !== 'unknown') {
    lines.push(`| Testing | ${formatTestFramework(stack.testFramework)} | - |`);
  }
  if (stack.styling) {
    lines.push(`| Styling | ${stack.styling} | - |`);
  }
  if (stack.database) {
    lines.push(`| Database/ORM | ${stack.database} | - |`);
  }
  lines.push(`| Package Manager | ${stack.packageManager} | - |`);
  lines.push('');

  // Additional Tools
  if (stack.additionalTools.length > 0) {
    lines.push('### Additional Tools');
    lines.push(stack.additionalTools.map(t => `- ${t}`).join('\n'));
    lines.push('');
  }

  // Project Structure
  lines.push('## Project Structure');
  lines.push('');
  lines.push(`- **Type**: ${formatStructureType(patterns.structure.type)}`);
  lines.push(`- **Source Directory**: \`${patterns.structure.sourceDir}/\``);
  if (patterns.structure.testDir) {
    lines.push(`- **Test Directory**: \`${patterns.structure.testDir}/\``);
  }
  lines.push('');

  if (patterns.structure.keyDirectories.length > 0) {
    lines.push('### Key Directories');
    lines.push('');
    lines.push('| Directory | Purpose |');
    lines.push('|-----------|---------|');
    for (const dir of patterns.structure.keyDirectories) {
      lines.push(`| \`${dir.path}/\` | ${dir.purpose} |`);
    }
    lines.push('');
  }

  // Commands
  if (Object.keys(commands).length > 0) {
    lines.push('## Commands');
    lines.push('');
    lines.push('| Command | Description |');
    lines.push('|---------|-------------|');
    if (commands.dev) lines.push(`| \`${commands.dev}\` | Start development server |`);
    if (commands.build) lines.push(`| \`${commands.build}\` | Build for production |`);
    if (commands.test) lines.push(`| \`${commands.test}\` | Run tests |`);
    if (commands.lint) lines.push(`| \`${commands.lint}\` | Run linter |`);
    if (commands.format) lines.push(`| \`${commands.format}\` | Format code |`);
    if (commands.typecheck) lines.push(`| \`${commands.typecheck}\` | Type check |`);
    lines.push('');
  }

  // Code Conventions
  lines.push('## Code Conventions');
  lines.push('');

  // Naming
  lines.push('### Naming');
  lines.push('');
  lines.push('| Type | Convention |');
  lines.push('|------|------------|');
  if (patterns.naming.files.components) {
    lines.push(`| Component files | ${patterns.naming.files.components} |`);
  }
  if (patterns.naming.files.utilities) {
    lines.push(`| Utility files | ${patterns.naming.files.utilities} |`);
  }
  if (patterns.naming.files.tests) {
    lines.push(`| Test files | ${patterns.naming.files.tests} |`);
  }
  lines.push(`| Functions | ${patterns.naming.code.functions} |`);
  lines.push(`| Variables | ${patterns.naming.code.variables} |`);
  lines.push(`| Constants | ${patterns.naming.code.constants} |`);
  if (patterns.naming.code.types) {
    lines.push(`| Types/Interfaces | ${patterns.naming.code.types} |`);
  }
  if (patterns.naming.code.components) {
    lines.push(`| Components | ${patterns.naming.code.components} |`);
  }
  lines.push('');

  // Imports & Exports
  if (patterns.imports || patterns.exports) {
    lines.push('### Imports & Exports');
    lines.push('');
    if (patterns.imports) {
      lines.push(`- **Import style**: ${patterns.imports.style}`);
      if (patterns.imports.aliases && Object.keys(patterns.imports.aliases).length > 0) {
        lines.push('- **Path aliases**:');
        for (const [alias, path] of Object.entries(patterns.imports.aliases)) {
          lines.push(`  - \`${alias}\` â†’ \`${path}\``);
        }
      }
    }
    if (patterns.exports) {
      lines.push(`- **Export style**: ${patterns.exports.style}`);
    }
    lines.push('');
  }

  // Rules section (placeholder)
  lines.push('## Project Rules');
  lines.push('');
  lines.push('<!-- Add project-specific rules here -->');
  lines.push('');
  lines.push('### Must Do');
  lines.push('- Follow the established naming conventions');
  lines.push('- Write tests for new features');
  lines.push('- Run linter before committing');
  lines.push('');
  lines.push('### Prefer');
  lines.push('- Functional components over class components');
  lines.push('- Named exports over default exports');
  lines.push('');

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('## Proteus Metadata');
  lines.push('');
  lines.push('```yaml');
  lines.push('version: 0.1.0');
  lines.push(`generated: ${new Date().toISOString()}`);
  lines.push(`confidence: ${Math.round(confidence.overall * 100)}%`);
  lines.push('```');
  lines.push('');
  lines.push('*This file was generated by [Proteus](https://github.com/your-username/proteus). Update with `proteus update`.*');

  return lines.join('\n');
}

// ============================================
// Formatting Helpers
// ============================================

function formatLanguage(lang: string): string {
  const map: Record<string, string> = {
    typescript: 'TypeScript',
    javascript: 'JavaScript',
    go: 'Go',
    python: 'Python',
    rust: 'Rust',
    ruby: 'Ruby',
    java: 'Java',
    php: 'PHP',
  };
  return map[lang] || lang;
}

function formatFramework(fw: string): string {
  const map: Record<string, string> = {
    nextjs: 'Next.js',
    react: 'React',
    vue: 'Vue.js',
    angular: 'Angular',
    svelte: 'Svelte',
    express: 'Express',
    fastify: 'Fastify',
    nestjs: 'NestJS',
    gin: 'Gin',
    echo: 'Echo',
    fiber: 'Fiber',
    django: 'Django',
    flask: 'Flask',
    fastapi: 'FastAPI',
    rails: 'Ruby on Rails',
    spring: 'Spring',
    laravel: 'Laravel',
    actix: 'Actix Web',
    axum: 'Axum',
  };
  return map[fw] || fw;
}

function formatTestFramework(tf: string): string {
  const map: Record<string, string> = {
    jest: 'Jest',
    vitest: 'Vitest',
    mocha: 'Mocha',
    pytest: 'pytest',
    'go-test': 'Go testing',
    rspec: 'RSpec',
    junit: 'JUnit',
    phpunit: 'PHPUnit',
  };
  return map[tf] || tf;
}

function formatStructureType(type: string): string {
  const map: Record<string, string> = {
    flat: 'Flat (simple)',
    'feature-based': 'Feature-based (modular)',
    'layer-based': 'Layer-based (MVC/Clean)',
    hybrid: 'Hybrid',
  };
  return map[type] || type;
}
