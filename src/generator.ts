import type { AnalysisResult, GeneratorOptions } from './types.js';
import type { ProjectDocuments } from './detectors/documents.js';
import {
  isClaudeAvailable,
  generateClaudeMdContent as claudeGenerateClaudeMd,
} from './claude-bridge.js';

export interface GenerateOptions extends GeneratorOptions {
  documents?: ProjectDocuments;
  verbose?: boolean;
}

/**
 * Generate CLAUDE.md content using Claude Code
 * Falls back to template-based generation if Claude is not available
 */
export function generateClaudeMd(
  result: AnalysisResult,
  options: GenerateOptions
): string {
  const documents = options.documents || { existingAgents: [] };

  // Try Claude Code first
  if (isClaudeAvailable()) {
    try {
      if (options.verbose) {
        console.log('ðŸ¤– Claude Codeã‚’ä½¿ç”¨ã—ã¦CLAUDE.mdã‚’ç”Ÿæˆä¸­...');
      }
      return claudeGenerateClaudeMd(result, documents, { verbose: options.verbose });
    } catch (error) {
      console.warn('âš ï¸ Claude Codeå‘¼ã³å‡ºã—ã«å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¾ã™');
      if (options.verbose && error instanceof Error) {
        console.warn(`  è©³ç´°: ${error.message}`);
      }
    }
  } else if (options.verbose) {
    console.log('â„¹ï¸ Claude CodeãŒåˆ©ç”¨ã§ããªã„ãŸã‚ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™');
  }

  // Fallback to template-based generation
  if (options.template === 'minimal') {
    return generateMinimalFallback(result);
  }
  return generateFullFallback(result, options);
}

// ============================================
// Fallback Templates (when Claude is not available)
// ============================================

function generateMinimalFallback(result: AnalysisResult): string {
  const { projectName, stack, commands, patterns } = result;

  const lines: string[] = [];

  lines.push(`# ${projectName}`);
  lines.push('');
  lines.push('## Tech Stack');
  lines.push(`- **Language**: ${formatLanguage(stack.language)}${stack.languageVersion ? ` ${stack.languageVersion}` : ''}`);
  if (stack.framework !== 'unknown') {
    lines.push(`- **Framework**: ${formatFramework(stack.framework)}${stack.frameworkVersion ? ` ${stack.frameworkVersion}` : ''}`);
  }
  if (stack.testFramework !== 'unknown') {
    lines.push(`- **Testing**: ${formatTestFramework(stack.testFramework)}`);
  }
  lines.push('');

  if (Object.keys(commands).length > 0) {
    lines.push('## Commands');
    lines.push('```bash');
    if (commands.dev) lines.push(`# Development\n${commands.dev}`);
    if (commands.build) lines.push(`\n# Build\n${commands.build}`);
    if (commands.test) lines.push(`\n# Test\n${commands.test}`);
    if (commands.lint) lines.push(`\n# Lint\n${commands.lint}`);
    lines.push('```');
    lines.push('');
  }

  lines.push('## Conventions');
  if (patterns.naming.files.components) {
    lines.push(`- Component files: ${patterns.naming.files.components}`);
  }
  if (patterns.naming.files.tests) {
    lines.push(`- Test files: ${patterns.naming.files.tests}`);
  }
  if (patterns.structure.type !== 'unknown') {
    lines.push(`- Project structure: ${formatStructureType(patterns.structure.type)}`);
  }
  lines.push('');

  lines.push('---');
  lines.push(`*Generated by Proteus (fallback mode) on ${new Date().toISOString().split('T')[0]}*`);

  return lines.join('\n');
}

function generateFullFallback(result: AnalysisResult, options: GeneratorOptions): string {
  const { projectName, description, stack, commands, patterns, confidence } = result;

  const lines: string[] = [];

  lines.push(`# ${projectName}`);
  lines.push('');

  if (description) {
    lines.push(`> ${description}`);
    lines.push('');
  }

  lines.push('## Tech Stack');
  lines.push('');
  lines.push('| Category | Technology | Version |');
  lines.push('|----------|------------|---------|');
  lines.push(`| Language | ${formatLanguage(stack.language)} | ${stack.languageVersion || '-'} |`);
  if (stack.framework !== 'unknown') {
    lines.push(`| Framework | ${formatFramework(stack.framework)} | ${stack.frameworkVersion || '-'} |`);
  }
  if (stack.testFramework !== 'unknown') {
    lines.push(`| Testing | ${formatTestFramework(stack.testFramework)} | - |`);
  }
  lines.push(`| Package Manager | ${stack.packageManager} | - |`);
  lines.push('');

  if (stack.additionalTools.length > 0) {
    lines.push('### Additional Tools');
    lines.push(stack.additionalTools.map(t => `- ${t}`).join('\n'));
    lines.push('');
  }

  lines.push('## Project Structure');
  lines.push('');
  lines.push(`- **Type**: ${formatStructureType(patterns.structure.type)}`);
  lines.push(`- **Source Directory**: \`${patterns.structure.sourceDir}/\``);
  if (patterns.structure.testDir) {
    lines.push(`- **Test Directory**: \`${patterns.structure.testDir}/\``);
  }
  lines.push('');

  if (Object.keys(commands).length > 0) {
    lines.push('## Commands');
    lines.push('');
    lines.push('| Command | Description |');
    lines.push('|---------|-------------|');
    if (commands.dev) lines.push(`| \`${commands.dev}\` | Start development server |`);
    if (commands.build) lines.push(`| \`${commands.build}\` | Build for production |`);
    if (commands.test) lines.push(`| \`${commands.test}\` | Run tests |`);
    if (commands.lint) lines.push(`| \`${commands.lint}\` | Run linter |`);
    lines.push('');
  }

  lines.push('## Code Conventions');
  lines.push('');
  lines.push('### Naming');
  lines.push('');
  lines.push('| Type | Convention |');
  lines.push('|------|------------|');
  lines.push(`| Functions | ${patterns.naming.code.functions} |`);
  lines.push(`| Variables | ${patterns.naming.code.variables} |`);
  lines.push(`| Constants | ${patterns.naming.code.constants} |`);
  if (patterns.naming.code.types) {
    lines.push(`| Types/Interfaces | ${patterns.naming.code.types} |`);
  }
  lines.push('');

  lines.push('---');
  lines.push('');
  lines.push('## Proteus Metadata');
  lines.push('');
  lines.push('```yaml');
  lines.push(`version: ${options.version}`);
  lines.push(`generated: ${new Date().toISOString()}`);
  lines.push(`confidence: ${Math.round(confidence.overall * 100)}%`);
  lines.push('mode: fallback (Claude Code not available)');
  lines.push('```');
  lines.push('');
  lines.push('*This file was generated by [Proteus](https://github.com/ischca/proteus) in fallback mode.*');
  lines.push('*Re-run with Claude Code available for better results.*');

  return lines.join('\n');
}

// ============================================
// Formatting Helpers
// ============================================

function formatLanguage(lang: string): string {
  const map: Record<string, string> = {
    typescript: 'TypeScript',
    javascript: 'JavaScript',
    go: 'Go',
    python: 'Python',
    rust: 'Rust',
    ruby: 'Ruby',
    java: 'Java',
    php: 'PHP',
  };
  return map[lang] || lang;
}

function formatFramework(fw: string): string {
  const map: Record<string, string> = {
    nextjs: 'Next.js',
    react: 'React',
    vue: 'Vue.js',
    angular: 'Angular',
    svelte: 'Svelte',
    express: 'Express',
    fastify: 'Fastify',
    nestjs: 'NestJS',
    gin: 'Gin',
    echo: 'Echo',
    fiber: 'Fiber',
    django: 'Django',
    flask: 'Flask',
    fastapi: 'FastAPI',
    rails: 'Ruby on Rails',
    spring: 'Spring',
    laravel: 'Laravel',
    actix: 'Actix Web',
    axum: 'Axum',
  };
  return map[fw] || fw;
}

function formatTestFramework(tf: string): string {
  const map: Record<string, string> = {
    jest: 'Jest',
    vitest: 'Vitest',
    mocha: 'Mocha',
    pytest: 'pytest',
    'go-test': 'Go testing',
    rspec: 'RSpec',
    junit: 'JUnit',
    phpunit: 'PHPUnit',
  };
  return map[tf] || tf;
}

function formatStructureType(type: string): string {
  const map: Record<string, string> = {
    flat: 'Flat (simple)',
    'feature-based': 'Feature-based (modular)',
    'layer-based': 'Layer-based (MVC/Clean)',
    hybrid: 'Hybrid',
  };
  return map[type] || type;
}
